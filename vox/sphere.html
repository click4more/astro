<!DOCTYPE html>
<title>Voxel Test</title>

<h1>Voxel Test</h1>

<canvas id="viewport" width="800" height="600" style="height:1200px;width900px"></canvas>


<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertPos;

uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;

varying vec3 vFragPos;

void main(void) {
  vec4 fragPos = vec4(aVertPos,1.0);
  vFragPos = fragPos.xyz / fragPos.w;
  gl_Position = uPMatrix * uMVMatrix * vec4(aVertPos, 1.0);
}
</script>






<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;

uniform sampler2D uChunkTex;

uniform vec3 uEyePos;
varying vec3 vFragPos;

void main(void) {
  gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);

  vec3 rayDir = normalize(vFragPos - uEyePos);
  float eps = 0.0001;
  vec3 fragPos = vFragPos + eps*rayDir;

  vec3 chunkRoot = 16.0*floor(fragPos*(1.0/16.0));
  vec3 step = abs(vec3(1.0/rayDir.x, 1.0/rayDir.y, 1.0/rayDir.z));
  vec3 blockOffset = fragPos - floor(fragPos);
  float minDist = 1e20;
  for(int dir = 0; dir < 3; dir++) {
    for(int i = 0; i < 16; i++){
      float dist;
      if(dir == 0) {
          dist = step.x * (float(i) - blockOffset.x);
      } else if (dir == 1) {
          dist = step.y * (float(i) - blockOffset.y);
      } else {
          dist = step.z * (float(i) - blockOffset.z);
      }
      vec3 intersect = fragPos + rayDir*(dist+eps);
      vec3 blockIx = intersect - chunkRoot;
      if(blockIx.x < 0.0 || blockIx.x >= 16.0 ||
         blockIx.y < 0.0 || blockIx.y >= 16.0 ||
         blockIx.z < 0.0 || blockIx.z >= 16.0){
        if(i == 0) continue;
        break;
      }
       
      //vec2 texCoord = vec2((blockIx.x)/256.0, (float(int(blockIx.y)*16) + blockIx.z)/256.0);
      ///vec4 texel = texture2D(uChunkTex, texCoord);
      ivec3 ix = ivec3(blockIx);
      vec4 texel = ((ix.x==3||ix.x==7) && (ix.y==3||ix.y==7) && (ix.z==3||ix.z==7)) ? vec4(1,0,0,1) : vec4(0,0,0,0);
      if(abs(texel) != 0.0 && dist < minDist) {
        gl_FragColor = texel;
        minDist = dist;
        break;
      }
    }
  }
}

</script>

<script src="sylvester.src.js"></script>

<script src="glUtils.js"></script>

<script>
var gl = initGL();
configureGL();
var shader = initShaderProgram();
var buffers = initUnitCube();
var tex = initChunkTex();
render();

function initGL(){
    var canvas = document.getElementById("viewport");
    return canvas.getContext("webgl");
}

function configureGL() {
    gl.clearColor(0,0,0,1);
    gl.clearDepth(1);
    gl.enable(gl.DEPTH_TEST);
}

/**
 * Compiles, links, and uses the shader program.
 * Returns a map from the name of each uniform or attribute to its location.
 */
function initShaderProgram() {
    var vertexShader = initShader("shader-vs");
    var fragmentShader = initShader("shader-fs");

    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);

    var uPMatrix = gl.getUniformLocation(shaderProgram, "uPMatrix");
    var uMVMatrix = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    var uEyePos = gl.getUniformLocation(shaderProgram, "uEyePos");
    var uChunkTex = gl.getUniformLocation(shaderProgram, "uChunkTex");
    var aVertPos = gl.getAttribLocation(shaderProgram, "aVertPos");
    gl.enableVertexAttribArray(aVertPos);
    return {
        "aVertPos": aVertPos,
        "uPMatrix": uPMatrix,
        "uMVMatrix": uMVMatrix,
        "uEyePos": uEyePos,
        "uChunkTex": uChunkTex
    };
}

/*
 * Compiles a single vertex or fragment shader.
 * Expects the ID of a <script> tag containing that shader.
 */
function initShader(id) {
    var scriptTag = document.getElementById(id);
    var script = scriptTag.firstChild.textContent;
    var shader;
    if(scriptTag.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if(scriptTag.type == "x-shader/x-vertex"){
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        throw "Unknown shader type "+scriptTag.type+" on shader "+id;
    }
    gl.shaderSource(shader, script);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
        throw "Compile error in shader "+id+": "+gl.getShaderInfoLog(shader);
    }
    return shader;
}

/*
 * Uses bufferData() to populate all buffers.
 * Returns a map from the buffer {"bVertPos", "bVertIdx"} to the buffer location.
 */
function initUnitCube() {
    var bVertPos = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bVertPos);
    var vertices = [
       // Front face
       0.0,  0.0,  1.0,
       1.0,  0.0,  1.0,
       1.0,  1.0,  1.0,
       0.0,  1.0,  1.0,
      
       // Back face
       0.0,  0.0,  0.0,
       0.0,  1.0,  0.0,
       1.0,  1.0,  0.0,
       1.0,  0.0,  0.0,
      
       // Top face
       0.0,  1.0,  0.0,
       0.0,  1.0,  1.0,
       1.0,  1.0,  1.0,
       1.0,  1.0,  0.0,
      
       // Bottom face
       0.0,  0.0,  0.0,
       1.0,  0.0,  0.0,
       1.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
      
       // Right face
       1.0,  0.0,  0.0,
       1.0,  1.0,  0.0,
       1.0,  1.0,  1.0,
       1.0,  0.0,  1.0,
      
       // Left face
       0.0,  0.0,  0.0,
       0.0,  0.0,  1.0,
       0.0,  1.0,  1.0,
       0.0,  1.0,  0.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array($V(vertices).x(16).flatten()), gl.STATIC_DRAW); 

    var bVertIdx = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bVertIdx);
    var vertIdx = [
      0,  1,  2,      0,  2,  3,    // front
      4,  5,  6,      4,  6,  7,    // back
      8,  9,  10,     8,  10, 11,   // top
      12, 13, 14,     12, 14, 15,   // bottom
      16, 17, 18,     16, 18, 19,   // right
      20, 21, 22,     20, 22, 23    // left
    ];
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertIdx), gl.STATIC_DRAW);

    return {
        "bVertPos": bVertPos,
        "bVertIdx": bVertIdx
    };
}

function initChunkTex() {
    var tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    // (X across, Z down) = one 16x16 frame for Y=0. Next frame below for Y=1, etc.
    var img = new Uint8Array(256*256*4);
    setChunk(img, 0, 0, 0, 0xff0000);
    setChunk(img, 0, 0,15, 0xff0000);
    setChunk(img, 0,15, 0, 0xff0000);
    setChunk(img, 0,15,15, 0xff0000);
    setChunk(img,15, 0, 0, 0xff0000);
    setChunk(img,15, 0,15, 0xff0000);
    setChunk(img,15,15, 0, 0xff0000);
    setChunk(img,15,15,15, 0xff0000);
    setChunk(img, 7, 4, 5, 0xff0000);
    setChunk(img,10, 4, 6, 0xff0000);
    setChunk(img,12, 5, 3, 0xff0000);
    setChunk(img, 5, 5,15, 0xff0000);
    setChunk(img, 7,11,15, 0xff0000);
    setChunk(img,10,11, 3, 0xff0000);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
    return tex;
}

function setChunk(img, x, y, z, color) {
    var ix = 256*16*y + 256*z + x;
    img[ix*4 + 0] = (color) & 0xff;
    img[ix*4 + 1] = (color >> 8) & 0xff;
    img[ix*4 + 2] = (color >> 16) & 0xff;
    img[ix*4 + 3] = 255;
}

function render() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    var matProj = makePerspective(45, 800/600, 0.1, 100);
    gl.uniformMatrix4fv(shader.uPMatrix, false, new Float32Array(matProj.flatten()));

    renderCube();

    requestAnimationFrame(render);
}

function renderCube() {
    var t = new Date().getTime() / 1000.0;

    var loc = $V([0,0,-64]);
    var matModelView = Matrix.I(4)
        .x(Matrix.Translation(loc).ensure4x4())
        .x(Matrix.RotationY(t*0.5).ensure4x4())
        .x(Matrix.RotationZ(Math.sin(t*0.3)).ensure4x4());
    gl.uniformMatrix4fv(shader.uMVMatrix, false, new Float32Array(matModelView.flatten()));

    var eyeLoc = matModelView.inverse()
        .x($V([0,0,0,1]));
    gl.uniform3fv(shader.uEyePos, new Float32Array([
          eyeLoc.elements[0] / eyeLoc.elements[3],
          eyeLoc.elements[1] / eyeLoc.elements[3],
          eyeLoc.elements[2] / eyeLoc.elements[3],
        ]));

    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.bVertPos); // point gl.ARRAY_BUFFER to bVertPos
    gl.vertexAttribPointer(shader.aVertPos, 3, gl.FLOAT, false, 0, 0); // point aVertPos to gl.ARRAY_BUFFER
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.bVertIdx);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.uniform1i(shader.uChunkTex, 0);

    gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
}

</script>

