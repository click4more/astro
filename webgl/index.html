<html>

<head>
<title>Alien Planets by Dan Posch and Jiwon Kim</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<link href='http://fonts.googleapis.com/css?family=Titillium+Web:400,300,600' rel='stylesheet' type='text/css'>
<link href='controls.css' rel='stylesheet' type='text/css'>
<style type="text/css">
body {
}

#space-webgl {
    display: block;
    clear: left;
    left: 0;
}

#space-d3 {
    display: block;
    clear: left;
    background-color: #000;
    width: 800px;
    height: 400px;
}

.planet {
}

.solar {
    fill: #04B4AE;
    stroke-width: 2px;
    stroke: #0B4C5F;
}

.extrasolar {
    fill: rgba(255, 255, 255, 0.1);
    stroke-width: 1px;
    stroke: rgba(200, 200, 200, 0.8);
}

.solar-orbit {
    fill: none;
    stroke-width: 2px;
    stroke: #aaa;
}

.exo-orbit {
    fill: none;
    stroke-width: 1px;
    stroke: rgba(255, 255, 255, 0.1);
}

.selected-orbit {
    fill: none;
    stroke-width: 3px;
    stroke: #0f0;
}


</style>

<link rel="stylesheet" href="http://code.jquery.com/ui/1.9.0/themes/base/jquery-ui.css" />
<script type="text/javascript" src="jquery-1.8.2.min.js"></script>  
<script src="http://code.jquery.com/ui/1.9.0/jquery-ui.js"></script>
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="d3.v2.js"></script>

<!-- line shaders --!>
<script id="line-shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    void main() {
        gl_FragColor = vec4(1.,1.,1.,1.);
    }
</script>

<script id="line-shader-vs" type="x-shader/x-vertex">
    precision mediump float;

    attribute vec3 vertexPosition; 

    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;

    void main() {
        gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
    }
</script>

<!-- exoplanet shaders --!>
<script id="exoplanet-shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    // Use texture
    uniform int textureFlag;
    uniform int lightingFlag;
    uniform sampler2D textureSampler;
    uniform vec3 exoplanetColor;

    // These are the input params per fragment,
    // interpolated by webGL
    varying vec3 eyePosition;
    varying vec3 normal;
    varying vec2 textureCoord; // texture coords
    varying vec3 lightPosition; // position of light in camera pos

    vec3 getMaterialColor() {
        if(textureFlag==1) {
            vec4 textureColor = texture2D(textureSampler, vec2(textureCoord.s, textureCoord.t));
            return textureColor.rgb;
        } else {
            return exoplanetColor;
        }
    }

    void main(void) {
        // TODO: pass in instead of hard-coding
        // diffuse, ambient, and specular materials
        vec3 Kd = getMaterialColor();

        if(lightingFlag==0) {
            gl_FragColor = vec4(Kd, 1.);
            return;
        }
        
        // light source (hardcoded for now)
        vec3 lightColor = vec3(1., 1., 1.);

        // Normalized normal
        vec3 N = normalize(normal);

        // point light from (0,0,0), which is where the camera is always
        vec3 L = normalize(lightPosition - eyePosition);
        vec3 V = normalize(-eyePosition);
        vec3 R = normalize(reflect(-L, N));

        vec3 Ks = vec3(1, 1, 1);
        vec3 Ka = vec3(0.2, 0.2, 0.2);

        // compute the diffuse color coefficient
        float Rd = max(0., dot(L, N));

        vec3 diffuse = Rd * Kd * lightColor;
        vec3 ambient = Ka * Kd * lightColor;
        vec3 specular = pow(max(0.,dot(R,V)), 2.) * vec3(0.2,0.2,0.2);

        // Tell webgl what the fragment color is
        gl_FragColor = vec4(diffuse + ambient + specular, 1.);
    }
</script>

<script id="exoplanet-shader-vs" type="x-shader/x-vertex">
    // These are the input params per vertex,
    // specified when we bind vertex positions, normals, and
    // text coords as attributes
    attribute vec3 vertexPosition;
    attribute vec3 vertexNormal;
    attribute vec2 vertexTextureCoord;

    // The modelview, projection, and normal matrix passed in
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uLightPosition;

    // These are the output values for the shader, to be
    // interpolated across vertices and passed in per fragment
    // to the fragment shader
    varying vec3 eyePosition; // pos of vertex in eye (camera) space
    varying vec3 normal; // normal at vertex
    varying vec2 textureCoord;
    varying vec3 lightPosition;

    void main(void) {
        // Transform vertex to get eye-space position of vertex
        vec4 eyePositionHomo = uMVMatrix*vec4(vertexPosition, 1); // homogenous
        eyePosition = eyePositionHomo.xyz;

        // Transform normal appropriately and save
        normal = uNMatrix*vertexNormal;

        // Just copy texture coords
        textureCoord = vertexTextureCoord;

        // Transform light position into eye space
        lightPosition = (uMVMatrix*vec4(uLightPosition, 1)).xyz;
        
        // Transform again to get clip-space coordinates via the
        // projection matrix. The gl_Position variable tells webGL
        // where the vertex should go
        gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);

    }
</script>

<script type="text/javascript">
    
    var solarsystemData;
    var exoplanetData;
    var allBodies = {};
    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
            return false;
        } else {
            return true;
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    // Creates a ready-to-use shader program using given fs and vs
    function createShaderProgram(fsid, vsid, isLineShader) {
        var fs = getShader(gl, fsid);
        var vs = getShader(gl, vsid);

        p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);

        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        
        gl.useProgram(p);

        // enable vertices to be passed in at once as attributes
        p.vertexPositionAttribute = gl.getAttribLocation(p, "vertexPosition");
        gl.enableVertexAttribArray(p.vertexPositionAttribute);
        
        // Remember locations for uniform variables for matrices
        p.pMatrixUniform = gl.getUniformLocation(p, "uPMatrix");
        p.mvMatrixUniform = gl.getUniformLocation(p, "uMVMatrix");

        if(!isLineShader) {
            // enable vertex normals to be passed in at once as attributes
            p.vertexNormalAttribute = gl.getAttribLocation(p, "vertexNormal");
            gl.enableVertexAttribArray(p.vertexNormalAttribute);
            
            // normal matrix
            p.nMatrixUniform = gl.getUniformLocation(p, "uNMatrix");
            
            // texture coordinates as attributes
            p.textureCoordAttribute = gl.getAttribLocation(p, "vertexTextureCoord");
            gl.enableVertexAttribArray(p.textureCoordAttribute); 
           
            // texture uniforms
            p.samplerUniform = gl.getUniformLocation(p, "textureSampler");
            p.textureFlag = gl.getUniformLocation(p, "textureFlag");
            
            // lighting uniforms
            p.lightingFlag = gl.getUniformLocation(p, "lightingFlag");
            p.lightPosition = gl.getUniformLocation(p, "uLightPosition");
            p.exoplanetColor = gl.getUniformLocation(p, "exoplanetColor");
        }

        return p;
    }


    var currentProgram;
    var exoplanetShaderProgram;
    var lineShaderProgram;
    function initShaders() {
        exoplanetShaderProgram = createShaderProgram("exoplanet-shader-fs", "exoplanet-shader-vs", false);
        lineShaderProgram = createShaderProgram("line-shader-fs", "line-shader-vs", true);
    }

    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(currentProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(currentProgram.mvMatrixUniform, false, mvMatrix);

        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(currentProgram.nMatrixUniform, false, normalMatrix);
    }


    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }


    // Camera location, spherical coords center on the sun
    var distance = 1, azith = 0, elev = -10;

    // Mouse events
    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;

    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }
    function handleMouseUp(event) {
        mouseDown = false;
    }
    function handleMouseMove(event) {
        if (!mouseDown) {
            return;
        }
        // get the vector that we just dragged (dx, dy)
        var newX = event.clientX;
        var newY = event.clientY;
        var deltaX = newX - lastMouseX;
        var deltaY = newY - lastMouseY;
        lastMouseX = newX;
        lastMouseY = newY;

        // turn that into rotation
        var sens = 1./(distance*distance*500); //sensitivity
        azith -= deltaX * sens;
        elev -= deltaY * sens * 0.7;
    }


    // Key events
    var keysPressed = {}
    var zoomFactor = 0.01;
    function handleKeyDown(event) {
        var char = String.fromCharCode(event.keyCode);
        keysPressed[char] = true;
        if(char.toLowerCase() == "w"){
            zoom(-zoomFactor);
        } else if(char.toLowerCase() == "e"){
            zoom(-zoomFactor*5);
        } else if(char.toLowerCase() == "s"){
            zoom(zoomFactor);
        } else if(char.toLowerCase() == "d"){
            zoom(zoomFactor*5);
        }
    }
    function handleKeyUp(event) {
        keysPressed[String.fromCharCode(event.keyCode)] = false;
    }
    
    function zoom(factor){
        distance += factor;
    }


    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    function initTexture(texturePath) {
        texture = gl.createTexture();
        texture.image = new Image();
        texture.image.src = texturePath;
        return texture;
    }
   
    function getTemperatureEstimateMinMax(exoplanetData) {
        var min = 1.;
        var max = 0.; 
        for(var i=0; i<exoplanetData.length; i++) {
            var exoplanet = exoplanetData[i];
            var solarMass = exoplanet['st_mass']!="" ? exoplanet['st_mass'] : exoplanet['st_rad'];
            if(solarMass=="") continue;

            var ratio = solarMass / exoplanet['pl_orbsmax'];

            if(ratio < min) min = ratio;
            else if(ratio > max) max = ratio;
        }

        return {min: min, max: max};
    }

    function lerp(a, b, t) {
        return a*(1-t) + b*t;
    }

    function computeExoplanetColor(exoplanet, range) {
        // color gradient
        var blue = range.min;
        var yellow = (range.max-1.)*0.3;
        var red = range.max;
        
        var solarMass = exoplanet['st_mass']!="" ? exoplanet['st_mass'] : exoplanet['st_rad'];

        // if mass of star is unknown, return gray
        if(solarMass=="") {
            return {r: 0.3, g: 0.3, b: 0.3};
        }
        
        var value = solarMass / exoplanet['pl_orbsmax'];
        
        var r, g, b, t;
        if (value < yellow) {
            t = (value - blue)/(yellow - blue);
            r = lerp(0, 1, t);
            g = lerp(0, 1, t);
            b = lerp(1, 0, t);
        } else {
            t = (value - yellow)/(red - yellow);
            r = 1.;
            g = lerp(1, 0, t);
            b = 0.;
        }

        return {r: r, g: g, b: b};
    }

    function initBody(name, radius, azith, elev, orbitRadius, texturePath, exoplanetColor) {

        //TODO: modify according to radius
        var latitudeBands = 30;
        var longitudeBands = 30;

        var body = {};
        body.name = name;
        body.radius = radius;
        body.azith = azith;
        body.elev = elev;
        body.orbitRadius = orbitRadius;
        if(texturePath!="") {
            body.texture = initTexture(texturePath);
        } else if(exoplanetColor) {
            body.exoplanetColor = exoplanetColor;
        }

        // save for lookup
        allBodies[name] = body;

        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longitudeBands);
                var v = 1 - (latNumber / latitudeBands);

                normalData.push(x);
                normalData.push(y);
                normalData.push(z);
                textureCoordData.push(u);
                textureCoordData.push(v);
                vertexPositionData.push(body.radius * x);
                vertexPositionData.push(body.radius * y);
                vertexPositionData.push(body.radius * z);
            }
        }

        var indexData = [];
        for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indexData.push(first);
                indexData.push(second);
                indexData.push(first + 1);

                indexData.push(second);
                indexData.push(second + 1);
                indexData.push(first + 1);
            }
        }

        body.vertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, body.vertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
        body.vertexNormalBuffer.itemSize = 3;
        body.vertexNormalBuffer.numItems = normalData.length / 3;

        body.vertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, body.vertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
        body.vertexTextureCoordBuffer.itemSize = 2;
        body.vertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

        body.vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, body.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
        body.vertexPositionBuffer.itemSize = 3;
        body.vertexPositionBuffer.numItems = vertexPositionData.length / 3;

        body.vertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, body.vertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
        body.vertexIndexBuffer.itemSize = 1;
        body.vertexIndexBuffer.numItems = indexData.length;

        return body;
    }

    var sun;
    var bodies;
    var exoplanets;
    function initBodies() {
        bodies = [];
        exoplanets = [];
        var distanceMultiplier = 1.;
        var kmAu = 149597870; // mean distance from earth to sun in km
        var kmSunRadius = 695500;
        var auSunRadius = kmSunRadius/kmAu;
        var displayedSunRadius = auSunRadius;
        sun = initBody("Sun", auSunRadius, 0, 0, 0, 'textures/sun.gif', null);

        for(planet in solarsystemData) {
            planetData = solarsystemData[planet];
            bodies.push(
                initBody(
                    planet, // name
                    planetData['radiuse']/kmAu, //radius
                    5.0,
                    0.0,
                    distanceMultiplier*planetData['au']+displayedSunRadius, // orb radius
                    planetData['image'], // tex path
                    {r:0, g:0, b:0} // default body color
                )
            );
        }

        var azith = 0.0; //TODO: actual physical azith/elev instead of a spiral?
        var kmEarthRadius = solarsystemData['Earth']['radiuse'];
        var temperatureMinMax = getTemperatureEstimateMinMax(exoplanetData);
        for(var i=0; i<exoplanetData.length; i++) {
            var planet = exoplanetData[i];
            exoplanets.push(
                initBody(
                    planet['pl_hostname']+planet['pl_letter'], //name
                    1.*planet['pl_rade']*kmEarthRadius/kmAu, //radius
                    azith,
                    0.0, 
                    distanceMultiplier*planet['pl_orbsmax']+displayedSunRadius, //orbit radius
                    "", //texture path
                    computeExoplanetColor(planet, temperatureMinMax) // color of planet
                )
            );
            azith += 10.0;
        }
    }

    var planetZoomTarget = null, planetZoomT = 0.0;
    function handlePlanetZoom() {
        var selected = $('.ui-selected');

        if(!selected.exists()) {
            return;
        }
        
        planetZoomTarget = selected.attr("id");

        // start animation
        if(planetZoomT == 0){
            var body = allBodies[planetZoomTarget];
            var azith0 = azith;
            while(azith0 > body.azith) azith0 -= 360.0;
            if(body.azith - azith0 > 180.0) azith0 += 360;
            radiusMultiplier = body.name=="Sun" ? 1. : $('#radius-multiplier-slider').slider("value");
            planetZoomPoints = [
                {r:Math.abs(distance), elev:elev, azith:azith0},
                {r:body.orbitRadius + body.radius*radiusMultiplier*20, elev:body.elev, azith:body.azith}
            ];
        }

        // animation -- update the camera location
        var t = planetZoomT;
        azith = planetZoomPoints[0].azith*(1-t) + planetZoomPoints[1].azith*t;
        elev = planetZoomPoints[0].elev*(1-t) + planetZoomPoints[1].elev*t;
        // quadratic "bounce" for the camera distance from the sun, zoom out and "swoop" back in
        // dist = at^2 + bt + c
        var a = -10; 
        var b = planetZoomPoints[1].r - planetZoomPoints[0].r - a;
        var c = planetZoomPoints[0].r;
        distance = a*t*t + b*t + c;

        // end animation
        if(planetZoomT == 1.0){
            planetZoomT = 0.0;
            planetZoomTarget = 0.0;
            selected.removeClass('ui-selected');
        } else {
            // advance the animation
            planetZoomT += 1/30;
            if(planetZoomT > 1.0){
                planetZoomT = 1.0;
            }
        }
    }

    function setMatrices() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(30, gl.viewportWidth / gl.viewportHeight, 0.0001, 10000.0, pMatrix);
        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, [0, 0, -distance]);
        mat4.rotate(mvMatrix, -degToRad(elev), [1, 0, 0]);
        mat4.rotate(mvMatrix, -degToRad(azith), [0, 1, 0]);
    }

    // Draws everything - called per frame
    function drawScene() {
        var scaleOnlySolar = $('#scale-only-solarsystem-checkbox').is(':checked');
        var radiusMultiplier = $('#radius-multiplier-slider').slider("value");
        currentProgram = exoplanetShaderProgram;
        gl.useProgram(currentProgram);

        // Pass in light info
        gl.uniform3f(currentProgram.lightPosition, -10., 0., 0.);

        for(var i=0; i<=bodies.length; i++) {
            var scale = radiusMultiplier;
            mvPushMatrix();
            var body;
            if (i==bodies.length) {
                body = sun;
                gl.uniform1i(currentProgram.lightingFlag, 0);
                scale = 1.;
            } else {
                body = bodies[i];
                gl.uniform1i(currentProgram.lightingFlag, 1);
            }
            mat4.rotate(mvMatrix, degToRad(body.azith), [0,1,0]);
            mat4.rotate(mvMatrix, degToRad(body.elev), [1,0,0]);
            mat4.translate(mvMatrix, [0, 0, body.orbitRadius]);
            mat4.scale(mvMatrix, [scale, scale, scale]);

            handleLoadedTexture(body.texture);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, body.texture);
            gl.uniform1i(currentProgram.samplerUniform, 0);
            gl.uniform1i(currentProgram.textureFlag, 1);

            gl.bindBuffer(gl.ARRAY_BUFFER, body.vertexPositionBuffer);
            gl.vertexAttribPointer(currentProgram.vertexPositionAttribute, body.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, body.vertexTextureCoordBuffer);
            gl.vertexAttribPointer(currentProgram.textureCoordAttribute, body.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, body.vertexNormalBuffer);
            gl.vertexAttribPointer(currentProgram.vertexNormalAttribute, body.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, body.vertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, body.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            gl.bindTexture(gl.TEXTURE_2D, null);

            mvPopMatrix();

            var cameraPos = [0,0,0];
            mat4.multiplyVec3(mvMatrix, cameraPos);
        }
        
        // Draw exoplanets
        var scale = scaleOnlySolar ? 1. : radiusMultiplier;
        for(var i=0; i<exoplanets.length; i++) {
            mvPushMatrix();
            mat4.rotate(mvMatrix, degToRad(exoplanets[i].azith), [0,1,0]);
            mat4.rotate(mvMatrix, degToRad(exoplanets[i].elev), [1,0,0]);
            mat4.translate(mvMatrix, [0, 0, (exoplanets[i].orbitRadius)]);
            mat4.scale(mvMatrix, [scale, scale, scale]);
            
            // Turn off texturing
            gl.uniform1i(currentProgram.textureFlag, 0);

            // Turn on lighting
            gl.uniform1i(currentProgram.lightingFlag, 1);

            // Set planet color
            gl.uniform3f(
                currentProgram.exoplanetColor,
                exoplanets[i].exoplanetColor.r,
                exoplanets[i].exoplanetColor.g,
                exoplanets[i].exoplanetColor.b
            )

            gl.bindBuffer(gl.ARRAY_BUFFER, exoplanets[i].vertexPositionBuffer);
            gl.vertexAttribPointer(currentProgram.vertexPositionAttribute, exoplanets[i].vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, exoplanets[i].vertexNormalBuffer);
            gl.vertexAttribPointer(currentProgram.vertexNormalAttribute, exoplanets[i].vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, exoplanets[i].vertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, exoplanets[i].vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

            mvPopMatrix();
        } 
    }

    function tick() {
        // if canvas is not visible, don't draw 
        if($('#space-webgl').css('display')=='none') {
            return;
        }
        requestAnimFrame(tick);
        setMatrices();
        drawScene();
        handlePlanetZoom();
    }


    function webGLStart() {
        var canvas = document.getElementById("space-webgl");
        initGL(canvas);
        initShaders();
        initBodies();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        canvas.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
    }

    function d3DrawCircles(data, cx, cy, cr, selector, classname) {
        // first clear
        svg.selectAll(selector).remove();

        // draw orbits for solar system planets
        var solarorbits = svg.selectAll(selector)
            .data(data)
            .enter()
            .append("circle")
            .attr("class", classname);

        solarorbits.attr("cx", cx)
            .attr("cy", cy)
            .attr("r", cr);
    }

    function d3HighlightSelectedPlanetOrbit(x, h) {
        // draw neon vertical line at selected planet
        var selected = $('.ui-selected');
        if(!selected.exists()) return;

        var selectedId = selected.attr("id");
        if(selectedId=="Sun") {
            d3.selectAll(".selected-orbit").remove();
            return;
        }

        console.log(selectedId);

        var rf = function(d) {
            return x(d['au']);
        };

        // TODO: if selected orbit is not visible, then decrease distance as appropriate
        d3DrawCircles([solarsystemData[selectedId]], 0, h/2, rf, ".selected-orbit", "selected-orbit");

        /*
        var selectedPlanetLine = d3.svg.line()
            .x(function(d) {
                return x(solarsystemData[selectedId]['au']);
            })
            .y(function(d) {
                return d*h;
            })
            .interpolate('linear');

        svg.selectAll(".selected-line").remove();
        svg.append('svg:path')
            .attr("class", "selected-line")
            .attr('d', selectedPlanetLine([0, 1]));
        */
    }

    function d3DrawScene() {
        var h = 400;
        var distanceMultiplier = $('#distance-multiplier-value').val();

        var x = d3.scale.linear()
            .domain([0, 770])
            .range([30, 770*distanceMultiplier]);

        var r = d3.scale.linear()
            .domain([0, 100000])
            .range([0, 30]);

        // draw orbits for extrasolar planets
        rf = function(d) {
            return x(parseFloat(d['pl_orbsmax']));
        };
        d3DrawCircles(exoplanetData, 0, h/2, rf, ".exo-orbit", "exo-orbit");
        
        // draw solar orbits
        var xf, yf, rf;
        rf = function(d) {
            return x(d['au']);
        };
        d3DrawCircles(solarData, 0, h/2, rf, ".solar-orbit", "solar-orbit");
        
        // draw the exoplanets
        xf = function(d) {
            var pd = x(parseFloat(d['pl_orbsmax']));
            return pd;
        };
        var kmEarthRadius = solarsystemData['Earth']['radiuse'];
        rf = function(d) {
            return r(parseFloat(d['pl_rade'])*kmEarthRadius);
        };
        d3DrawCircles(exoplanetData, xf, h/2, rf, ".planet.extrasolar", "planet extrasolar");
        
        // Vertical line for selected planet
        d3HighlightSelectedPlanetOrbit(x, h);
      
        // draw the solar system
        xf = function(d) {
            return x(d['au']);
        };
        rf = function(d) {
            return r(d['radiuse']);
        };
        d3DrawCircles(solarData, xf, h/2, rf, ".planet.solar", "planet solar");

    }

    var svg;
    var solarData;
    function d3Start() {
        // Clean data for appropriate use with d3
        solarData = []
        for(planetName in solarsystemData) {
            solarData.push(solarsystemData[planetName]);
        }

        svg = d3.select("body")
            .append("svg")
            .attr("id", "space-d3");

        d3DrawScene();
    }
    
    $.fn.exists = function () {
        return this.length !== 0;
    }

    $(document).ready(function() {
        // show appropriate controls and view
        $('#space-webgl').show();
        $('#radius-multiplier').show();
        $('#space-d3').hide();
        $('#distance-multiplier').hide();
        
        // Load data and start webgl visualization
        $.getJSON('solarsystem.json', function(sd) {
            solarsystemData = sd;
            $.getJSON('exoplanets_with_radii.json', function(ed) {
                exoplanetData = ed;
                webGLStart();
                d3Start();
            });
        });

        $('.zoom-control').selectable({
            selected: function(ev, ui) {
                d3DrawScene();  
            }
        });

        // Let user define radius scale, default to 1, the minimum.
        var rslider = $('#radius-multiplier-slider');
        var rvalue = $('#radius-multiplier-value');
        rslider.slider({
            range: "min",
            min: 1,
            max: 50,
            value: 1,
            slide: function(event, ui) {
                rvalue.val(ui.value);
            }
        });
        rvalue.val(rslider.slider("value"));
        rvalue.change(function() {
            var value = rvalue.val();
            if(value < 1) value = 1;
            else if(value > 50) value = 50;
            rvalue.val(value);
            if(value != rslider.slider("value")) {
                rslider.slider("value", value);
            }
        });
        
        // Let user scale distance to see crowded planets better
        var dslider = $('#distance-multiplier-slider');
        var dvalue = $('#distance-multiplier-value');
        dslider.slider({
            range: "min",
            min: 1,
            max: 2000,
            value: 19,
            slide: function(event, ui) {
                dvalue.val(ui.value);
                d3DrawScene();
                //$('.selected-ui').removeClass("selected-ui");
            }
        });
        dvalue.val(dslider.slider("value"));
        dvalue.change(function() {
            var value = dvalue.val();
            if(value < 1) value = 1;
            else if(value > 50) value = 50;
            dvalue.val(value);
            if(value != dslider.slider("value")) {
                dslider.slider("value", value);
                d3DrawScene();
                //$('.selected-ui').removeClass("selected-ui");
            }
        });
        

        $('#toggle-view').click(function() {
            // if no webgl support, then no toggle
            if(!gl) return;

            if($('#space-webgl').css("display")=="none") {
                $('#space-webgl').show();
                $('#space-webgl').css('display', 'block');
                $('#radius-multiplier').show();

                $('#space-d3').hide();
                $('#distance-multiplier').hide();
                
                // start webgl rendering loop again
                tick();
            } else {
                $('#space-webgl').hide();
                $('#radius-multiplier').hide();

                $('#space-d3').show();
                $('#distance-multiplier').show();
            }
        });

    });

</script>


</head>


<body>
    <div id="top">
        <div id="title">
            <h1>Alien Planets</h1>
            <h2>by <a href="http://dcpos.ch">Dan Posch</a> and <a href="http://jiwonk.im">Jiwon Kim</a></h2> 
            <p>
                You are looking at our sun and its planets, along with confirmed extrasolar planets that have radii and orbit data that is included in the solar system for perspective. The radii and distances are accurately scaled (relatively, of course), but you can increase the radii for a better view of the planets.
            </p> 
            <p>
                Use 'w' to zoom in, 'e' to do it faster. Use 's' to zoom out, 'd' to do it faster. Fiddle with the controls to change what you're looking at.
            </p>
        </div>
        <div id="zoom-and-scale-controls">
            <label for="zoom-control">Zoom: </label>
            <ul class="zoom-control">
                <li class="zoom" id="Sun"></li>
                <li class="zoom" id="Mercury"></li>
                <li class="zoom" id="Venus"></li>
                <li class="zoom" id="Earth"></li>
                <li class="zoom" id="Mars"></li>
                <li class="zoom" id="Jupiter"></li>
                <li class="zoom" id="Saturn"></li>
                <li class="zoom" id="Uranus"></li>
                <li class="zoom" id="Neptune"></li>
            </ul>
            <br />
            <div id="radius-multiplier">
                <label id="radius-multiplier-label" for="radius-multiplier-slider">Scale Radius:</label>
                <input type="text" id="radius-multiplier-value" />
                <div id="radius-multiplier-slider"></div>
                <br />
                <label id ="scale-only-solarsystem-label" for="scale-only-solarsystem-checkbox">Scale only solar system planets</label>
                <input type="checkbox" id="scale-only-solarsystem-checkbox" />
            </div>
            <div id="distance-multiplier">
                <label id="distance-multiplier-label" for="distance-multiplier-slider">Scale Distance:</label>
                <input type="text" id="distance-multiplier-value" />
                <div id="distance-multiplier-slider"></div>
            </div>
            <button id="toggle-view">Toggle View</button>
        </div>
    </div>

    <br />
    <canvas id="space-webgl" width="800" height="400"></canvas>
    <br/>

    <br/>
    <br/>
</body>

</html>
